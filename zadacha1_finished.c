#include<stdio.h>	//подключаем стандартную библиотеку для работы с printf
#include <stdlib.h>	//требуется для использования malloc

int    main()
{
/*
    int n = 4;  //указываем размерность матрицы(массива)  
    int mass[4][4]={    //объявим массив A. Для простоты описания и понимания я напишу через прямое присваивание и объявление массива, хотя стоило бы сделать иначе(через объявление указателя типа int и использования функции malloc для выделения памяти)
             {1,0,1,1},
             {0,0,1,1},
             {1,1,0,1},
             {0,1,0,1}
            };
    int mass2[4][4];    //объявляем второй массив, он будет является матрицей(массивом) A^T 
    
    
    //выведем массив - этот участок кода можно удалить, он лишь показательный
    for (int y = 0; y < n; y++)
    {
        for (int x = 0; x < n; x++)
        {
            printf("%d ",mass[y][x]);
        }
        printf("\n");
    }
    printf("\n");    //перенос строки
    
    //читаем массив и переводим его в десятичное число
    int hex = 0;
    for (int y = n-1; y >= 0; y--)
    {
        for (int x = 0; x < n; x++)
        {
            if(mass[y][x] == 1)
                hex+=1<<(x);
        }
        printf("%x",hex);    //выводим десятичное число как шестнадцатеричное
        hex = 0;
    }
    printf("\n\n");
*/
    int hex;
    int n;
    int **mass;
    int **mass2;
    scanf("%x", &hex);    //получим на вход число в 16-тиричном формате
    
    n = 4;    //условимся, что матрица 4х4, в ином случае нам придется высчитывать высоту матрицы по количеству 16-тичных чисел поданных на вход.
    int temp;
    //malloc - выделяет память и возвращает указатель(по сути мы таким образом можем создавать динамический массив)
    mass = (int **)malloc(sizeof(int **) * n);
    for(int i = 0; i < n;i++)
        *(mass+i) = (int *)malloc(sizeof(int *) * n);
    
    mass2 = (int **)malloc(sizeof(int **) * n);
    for(int i = 0; i < n;i++)
        *(mass2+i) = (int *)malloc(sizeof(int *) * n);



    //переведем 16-ти ричное число в матрицу
    for(int y = 0; y < n; y++)
    {
        temp = hex % 16; //берем остаток от деления hex на 16
        for(int x = 0; x < n; x++)
        {
            mass[y][x] = temp % 2;    //результатом temp % 2 будет 0 или 1, в зависимости делится ли temp без остатка или с ним 
            temp /= 2;    //условие равносильно temp = temp / 2
        }
        hex /= 16;    // отбросим 1 символ, который мы уже записали в матрицу
    }
    
    
    //вывод матрицы
    /*
    for (int y = 0; y < n; y++)
    {
        for (int x = 0; x < n; x++)
        {
            printf("%d ",mass[y][x]);
        }
        printf("\n");
    }
    printf("\n");    //перенос строки
    */
    
    //участок кода отвечающий за переводот матрицы
    for(int y = 0; y < n; y++)
    {
        for(int x = 0; x < n; x++)
        {
            //т.к нам надо лишь сместить с позиции y на x, а с x на y, то просто перепишем заменив x y местами в вспомогательный массив 
            mass2[x][y] = mass[y][x];
        }
    }
    /*
    //вывод второго(выходного) массива
    for (int y = 0; y < n; y++)
    {
        for (int x = 0; x < n; x++)
        {
            printf("%d ",mass2[y][x]);
        }
        printf("\n");
    }
    printf("\n");
    */
    //читаем массив и переводим его в десятичное число
    hex = 0;
    for (int y = n-1; y >= 0; y--)
    {
        for (int x = 0; x < n; x++)
        {
            if(mass2[y][x] == 1)
                hex+=1<<(x);
        }
        printf("%x",hex);    //выводим десятичное число как шестнадцатеричное
        hex = 0;
    }
    
    //после использования функции malloc требуется обязательно отчищать память, чтобы не было утечек памяти
    for(int i = 0; i < n; i++)
        free(*(mass + i));
    free(mass);
    for(int i = 0; i < n; i++)
        free(*(mass2 + i));
    free(mass2);
    
    return 0;
}
